var J=t=>{throw TypeError(t)};var z=(t,e,s)=>e.has(t)||J("Cannot "+s);var n=(t,e,s)=>(z(t,e,"read from private field"),s?s.call(t):e.get(t)),d=(t,e,s)=>e.has(t)?J("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,s),c=(t,e,s,r)=>(z(t,e,"write to private field"),r?r.call(t,s):e.set(t,s),s);var L=(t,e,s,r)=>({set _(i){c(t,e,i,s)},get _(){return n(t,e,r)}});import{j as U}from"./jsx-runtime-D_zvdyIk.js";import{a as Q,s as le,w as fe}from"./chunk-D4RADZKF-By21buN-.js";import{S as ie,m as ae,j as g,o as G,M as de,q as V,n as b,v as ge,w as ye,x as pe,g as me,y as W,d as X,z as ve,A as Y,B as Z,C as be,Q as Pe}from"./fetch-utils-CEdl9sdl.js";import{T as we}from"./index-CNgNZYQm.js";import{p as Oe}from"./index-DgMzxt3E.js";import{Q as Qe}from"./differenceInCalendarDays-D7TXt3rl.js";class j extends Error{}j.prototype.name="InvalidTokenError";function Ae(t){return decodeURIComponent(atob(t).replace(/(.)/g,(e,s)=>{let r=s.charCodeAt(0).toString(16).toUpperCase();return r.length<2&&(r="0"+r),"%"+r}))}function Me(t){let e=t.replace(/-/g,"+").replace(/_/g,"/");switch(e.length%4){case 0:break;case 2:e+="==";break;case 3:e+="=";break;default:throw new Error("base64 string is not of the correct length")}try{return Ae(e)}catch{return atob(e)}}function Ee(t,e){if(typeof t!="string")throw new j("Invalid token specified: must be a string");e||(e={});const s=e.header===!0?0:1,r=t.split(".")[s];if(typeof r!="string")throw new j(`Invalid token specified: missing part #${s+1}`);let i;try{i=Me(r)}catch(a){throw new j(`Invalid token specified: invalid base64 for part #${s+1} (${a.message})`)}try{return JSON.parse(i)}catch(a){throw new j(`Invalid token specified: invalid json for part #${s+1} (${a.message})`)}}var m,se,ke=(se=class extends ie{constructor(e={}){super();d(this,m);this.config=e,c(this,m,new Map)}build(e,s,r){const i=s.queryKey,a=s.queryHash??ae(i,s);let h=this.get(a);return h||(h=new Qe({client:e,queryKey:i,queryHash:a,options:e.defaultQueryOptions(s),state:r,defaultOptions:e.getQueryDefaults(i)}),this.add(h)),h}add(e){n(this,m).has(e.queryHash)||(n(this,m).set(e.queryHash,e),this.notify({type:"added",query:e}))}remove(e){const s=n(this,m).get(e.queryHash);s&&(e.destroy(),s===e&&n(this,m).delete(e.queryHash),this.notify({type:"removed",query:e}))}clear(){g.batch(()=>{this.getAll().forEach(e=>{this.remove(e)})})}get(e){return n(this,m).get(e)}getAll(){return[...n(this,m).values()]}find(e){const s={exact:!0,...e};return this.getAll().find(r=>G(s,r))}findAll(e={}){const s=this.getAll();return Object.keys(e).length>0?s.filter(r=>G(e,r)):s}notify(e){g.batch(()=>{this.listeners.forEach(s=>{s(e)})})}onFocus(){g.batch(()=>{this.getAll().forEach(e=>{e.onFocus()})})}onOnline(){g.batch(()=>{this.getAll().forEach(e=>{e.onOnline()})})}},m=new WeakMap,se),P,p,K,re,qe=(re=class extends ie{constructor(e={}){super();d(this,P);d(this,p);d(this,K);this.config=e,c(this,P,new Set),c(this,p,new Map),c(this,K,0)}build(e,s,r){const i=new de({mutationCache:this,mutationId:++L(this,K)._,options:e.defaultMutationOptions(s),state:r});return this.add(i),i}add(e){n(this,P).add(e);const s=N(e);if(typeof s=="string"){const r=n(this,p).get(s);r?r.push(e):n(this,p).set(s,[e])}this.notify({type:"added",mutation:e})}remove(e){if(n(this,P).delete(e)){const s=N(e);if(typeof s=="string"){const r=n(this,p).get(s);if(r)if(r.length>1){const i=r.indexOf(e);i!==-1&&r.splice(i,1)}else r[0]===e&&n(this,p).delete(s)}}this.notify({type:"removed",mutation:e})}canRun(e){const s=N(e);if(typeof s=="string"){const r=n(this,p).get(s),i=r==null?void 0:r.find(a=>a.state.status==="pending");return!i||i===e}else return!0}runNext(e){var r;const s=N(e);if(typeof s=="string"){const i=(r=n(this,p).get(s))==null?void 0:r.find(a=>a!==e&&a.state.isPaused);return(i==null?void 0:i.continue())??Promise.resolve()}else return Promise.resolve()}clear(){g.batch(()=>{n(this,P).forEach(e=>{this.notify({type:"removed",mutation:e})}),n(this,P).clear(),n(this,p).clear()})}getAll(){return Array.from(n(this,P))}find(e){const s={exact:!0,...e};return this.getAll().find(r=>V(s,r))}findAll(e={}){return this.getAll().filter(s=>V(e,s))}notify(e){g.batch(()=>{this.listeners.forEach(s=>{s(e)})})}resumePausedMutations(){const e=this.getAll().filter(s=>s.state.isPaused);return g.batch(()=>Promise.all(e.map(s=>s.continue().catch(b))))}},P=new WeakMap,p=new WeakMap,K=new WeakMap,re);function N(t){var e;return(e=t.options.scope)==null?void 0:e.id}function ee(t){return{onFetch:(e,s)=>{var R,w,H,o,f;const r=e.options,i=(H=(w=(R=e.fetchOptions)==null?void 0:R.meta)==null?void 0:w.fetchMore)==null?void 0:H.direction,a=((o=e.state.data)==null?void 0:o.pages)||[],h=((f=e.state.data)==null?void 0:f.pageParams)||[];let l={pages:[],pageParams:[]},k=0;const F=async()=>{let v=!1;const q=y=>{Object.defineProperty(y,"signal",{enumerable:!0,get:()=>(e.signal.aborted?v=!0:e.signal.addEventListener("abort",()=>{v=!0}),e.signal)})},ce=ge(e.options,e.fetchOptions),_=async(y,O,T)=>{if(v)return Promise.reject();if(O==null&&y.pages.length)return Promise.resolve(y);const x={client:e.client,queryKey:e.queryKey,pageParam:O,direction:T?"backward":"forward",meta:e.options.meta};q(x);const he=await ce(x),{maxPages:B}=e.options,$=T?ye:pe;return{pages:$(y.pages,he,B),pageParams:$(y.pageParams,O,B)}};if(i&&a.length){const y=i==="backward",O=y?De:te,T={pages:a,pageParams:h},x=O(r,T);l=await _(T,x,y)}else{const y=t??a.length;do{const O=k===0?h[0]??r.initialPageParam:te(r,l);if(k>0&&O==null)break;l=await _(l,O),k++}while(k<y)}return l};e.options.persister?e.fetchFn=()=>{var v,q;return(q=(v=e.options).persister)==null?void 0:q.call(v,F,{client:e.client,queryKey:e.queryKey,meta:e.options.meta,signal:e.signal},s)}:e.fetchFn=F}}}function te(t,{pages:e,pageParams:s}){const r=e.length-1;return e.length>0?t.getNextPageParam(e[r],e,s[r],s):void 0}function De(t,{pages:e,pageParams:s}){var r;return e.length>0?(r=t.getPreviousPageParam)==null?void 0:r.call(t,e[0],e,s[0],s):void 0}var u,A,M,D,C,E,I,S,ne,Ce=(ne=class{constructor(t={}){d(this,u);d(this,A);d(this,M);d(this,D);d(this,C);d(this,E);d(this,I);d(this,S);c(this,u,t.queryCache||new ke),c(this,A,t.mutationCache||new qe),c(this,M,t.defaultOptions||{}),c(this,D,new Map),c(this,C,new Map),c(this,E,0)}mount(){L(this,E)._++,n(this,E)===1&&(c(this,I,me.subscribe(async t=>{t&&(await this.resumePausedMutations(),n(this,u).onFocus())})),c(this,S,W.subscribe(async t=>{t&&(await this.resumePausedMutations(),n(this,u).onOnline())})))}unmount(){var t,e;L(this,E)._--,n(this,E)===0&&((t=n(this,I))==null||t.call(this),c(this,I,void 0),(e=n(this,S))==null||e.call(this),c(this,S,void 0))}isFetching(t){return n(this,u).findAll({...t,fetchStatus:"fetching"}).length}isMutating(t){return n(this,A).findAll({...t,status:"pending"}).length}getQueryData(t){var s;const e=this.defaultQueryOptions({queryKey:t});return(s=n(this,u).get(e.queryHash))==null?void 0:s.state.data}ensureQueryData(t){const e=this.defaultQueryOptions(t),s=n(this,u).build(this,e),r=s.state.data;return r===void 0?this.fetchQuery(t):(t.revalidateIfStale&&s.isStaleByTime(X(e.staleTime,s))&&this.prefetchQuery(e),Promise.resolve(r))}getQueriesData(t){return n(this,u).findAll(t).map(({queryKey:e,state:s})=>{const r=s.data;return[e,r]})}setQueryData(t,e,s){const r=this.defaultQueryOptions({queryKey:t}),i=n(this,u).get(r.queryHash),a=i==null?void 0:i.state.data,h=ve(e,a);if(h!==void 0)return n(this,u).build(this,r).setData(h,{...s,manual:!0})}setQueriesData(t,e,s){return g.batch(()=>n(this,u).findAll(t).map(({queryKey:r})=>[r,this.setQueryData(r,e,s)]))}getQueryState(t){var s;const e=this.defaultQueryOptions({queryKey:t});return(s=n(this,u).get(e.queryHash))==null?void 0:s.state}removeQueries(t){const e=n(this,u);g.batch(()=>{e.findAll(t).forEach(s=>{e.remove(s)})})}resetQueries(t,e){const s=n(this,u);return g.batch(()=>(s.findAll(t).forEach(r=>{r.reset()}),this.refetchQueries({type:"active",...t},e)))}cancelQueries(t,e={}){const s={revert:!0,...e},r=g.batch(()=>n(this,u).findAll(t).map(i=>i.cancel(s)));return Promise.all(r).then(b).catch(b)}invalidateQueries(t,e={}){return g.batch(()=>(n(this,u).findAll(t).forEach(s=>{s.invalidate()}),(t==null?void 0:t.refetchType)==="none"?Promise.resolve():this.refetchQueries({...t,type:(t==null?void 0:t.refetchType)??(t==null?void 0:t.type)??"active"},e)))}refetchQueries(t,e={}){const s={...e,cancelRefetch:e.cancelRefetch??!0},r=g.batch(()=>n(this,u).findAll(t).filter(i=>!i.isDisabled()).map(i=>{let a=i.fetch(void 0,s);return s.throwOnError||(a=a.catch(b)),i.state.fetchStatus==="paused"?Promise.resolve():a}));return Promise.all(r).then(b)}fetchQuery(t){const e=this.defaultQueryOptions(t);e.retry===void 0&&(e.retry=!1);const s=n(this,u).build(this,e);return s.isStaleByTime(X(e.staleTime,s))?s.fetch(e):Promise.resolve(s.state.data)}prefetchQuery(t){return this.fetchQuery(t).then(b).catch(b)}fetchInfiniteQuery(t){return t.behavior=ee(t.pages),this.fetchQuery(t)}prefetchInfiniteQuery(t){return this.fetchInfiniteQuery(t).then(b).catch(b)}ensureInfiniteQueryData(t){return t.behavior=ee(t.pages),this.ensureQueryData(t)}resumePausedMutations(){return W.isOnline()?n(this,A).resumePausedMutations():Promise.resolve()}getQueryCache(){return n(this,u)}getMutationCache(){return n(this,A)}getDefaultOptions(){return n(this,M)}setDefaultOptions(t){c(this,M,t)}setQueryDefaults(t,e){n(this,D).set(Y(t),{queryKey:t,defaultOptions:e})}getQueryDefaults(t){const e=[...n(this,D).values()],s={};return e.forEach(r=>{Z(t,r.queryKey)&&Object.assign(s,r.defaultOptions)}),s}setMutationDefaults(t,e){n(this,C).set(Y(t),{mutationKey:t,defaultOptions:e})}getMutationDefaults(t){const e=[...n(this,C).values()],s={};return e.forEach(r=>{Z(t,r.mutationKey)&&Object.assign(s,r.defaultOptions)}),s}defaultQueryOptions(t){if(t._defaulted)return t;const e={...n(this,M).queries,...this.getQueryDefaults(t.queryKey),...t,_defaulted:!0};return e.queryHash||(e.queryHash=ae(e.queryKey,e)),e.refetchOnReconnect===void 0&&(e.refetchOnReconnect=e.networkMode!=="always"),e.throwOnError===void 0&&(e.throwOnError=!!e.suspense),!e.networkMode&&e.persister&&(e.networkMode="offlineFirst"),e.queryFn===be&&(e.enabled=!1),e}defaultMutationOptions(t){return t!=null&&t._defaulted?t:{...n(this,M).mutations,...(t==null?void 0:t.mutationKey)&&this.getMutationDefaults(t.mutationKey),...t,_defaulted:!0}}clear(){n(this,u).clear(),n(this,A).clear()}},u=new WeakMap,A=new WeakMap,M=new WeakMap,D=new WeakMap,C=new WeakMap,E=new WeakMap,I=new WeakMap,S=new WeakMap,ne);const oe=new Ce({defaultOptions:{queries:{staleTime:0,gcTime:1e3*60*5,refetchOnWindowFocus:!1,refetchOnMount:!0,refetchOnReconnect:!0,retry:1}}}),xe=({children:t})=>U.jsxs(Pe,{client:oe,children:[U.jsx(Ie,{children:t}),U.jsx(we,{position:"top-right",richColors:!0})]}),ue=Q.createContext(void 0),Ie=({children:t})=>{const[e,s]=Q.useState(null),[r,i]=Q.useState(!1),[a,h]=Q.useState(!0),l=le(),k=fe().pathname,F=Oe.includes(k);Q.useEffect(()=>{(async()=>{h(!0);try{const f=localStorage.getItem("user");f?(s(JSON.parse(f)),i(!0)):(s(null),i(!1),F||l("/sign-in"))}catch(f){console.error("Auth check failed:",f)}finally{h(!1)}})()},[k,F,l]),Q.useEffect(()=>{const o=localStorage.getItem("token");let f;if(o)try{const{exp:v}=Ee(o),q=v*1e3-Date.now();q<=0?(w(),l("/sign-in")):f=setTimeout(()=>{w(),l("/sign-in")},q)}catch{r&&(w(),l("/sign-in"))}return()=>{f&&clearTimeout(f)}},[r]),Q.useEffect(()=>{const o=()=>{w(),l("/sign-in")};return window.addEventListener("force-logout",o),()=>{window.removeEventListener("force-logout",o)}},[]);const R=async o=>{var f;localStorage.setItem("user",JSON.stringify(o==null?void 0:o.user)),localStorage.setItem("token",o==null?void 0:o.token),s((o==null?void 0:o.user)||null),i(!0),h(!1),((f=o==null?void 0:o.user)==null?void 0:f.role)==="super_admin"?l("/important-tasks"):l("/dashboard")},w=()=>{localStorage.removeItem("user"),localStorage.removeItem("token"),s(null),i(!1),oe.clear()},H={user:e,isAuthenticated:r,isLoading:a,login:R,logout:w};return U.jsx(ue.Provider,{value:H,children:t})},Le=()=>{const t=Q.useContext(ue);if(!t)throw new Error("useAuth must be used within an AuthProvider");return t};export{Ie as A,xe as R,oe as q,Le as u};
